---
title: "Lab 6 - Spicy"
subtitle: "Performing Many Different Versions of an Analysis"
author: "Rachel Roggenkemper"
editor: source
---

This assignment will challenge your function writing abilities. I'm not going to lie, these functions are difficult but well within your reach. I do, however, want to recognize that not everyone is interested in being a "virtuoso" with their function writing. So, there are two options for this week's lab:

-   **Option 1:** Complete this lab assignment in search of virtuoso status with your function writing
-   **Option 2:** Complete one of the difficult functions (Exercise 1 or Exercise 2 and complete the "Alternative Lab 6".

```{r}
#| label: load packages 
#| message: false

library(tidyverse)
```

# Setting the Stage

My number one use case for writing functions and iteration / looping is to perform some exploration or modeling repeatedly for different "tweaked" versions. For example, our broad goal might be to fit a linear regression model to our data. However, there are often multiple choices that we have to make in practice:

-   Keep missing values or fill them in (imputation)?
-   Filter out outliers in one or more variables?

We can map these choices to **arguments** in a custom model-fitting function:

-   `impute`: TRUE or FALSE
-   `remove_outliers`: TRUE or FALSE

A function that implements the analysis and allows for variation in these choices:

```{r}
#| echo: true
#| eval: false
#| label: example-code-to-motivate-function

fit_model <- function(df, impute, remove_outliers, mod) {
    if (impute) {
        df <- some_imputation_function(df)
    }
    
    if (remove_outliers) {
        df <- function_for_removing_outliers(df)
    }
    
    lm(mod, data = df)
}
```

# Helper Functions

**Exercise 1:** Write a function that removes outliers in a dataset. The user should be able to supply the dataset, the variables to remove outliers from, and a threshold on the number of SDs away from the mean used to define outliers. *Hint 1: You will need to calculate a z-score to filter the values!* *Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*

```{r}
#| label: exercise-1

#' @param df A data frame.
#' @param ... Unquoted names of columns to check for outliers.
#' @param sd_thresh Numeric. The threshold for the number of standard deviations
#'   away from the mean to define an outlier. Default is 3.
#' @return A data frame with outliers removed from the specified numeric columns.
#'   Rows are removed if any of the specified numeric columns has a value
#'   whose absolute z-score exceeds sd_thresh. Non-numeric columns specified
#'   in ... are ignored with a warning.


remove_outliers <- function(df, ..., sd_thresh = 3) {
  # Capture the unquoted column names passed via ...
  vars_to_check <- rlang::enquos(...)

  # If no variables are specified, return the original dataframe with a warning
  if (length(vars_to_check) == 0) {
    warning("No variables specified for outlier removal. Returning original data frame.")
    return(df)
  }

  # Get the names of the specified columns
  selected_col_names <- purrr::map_chr(vars_to_check, rlang::as_name)

  # Identify which of the selected columns are actually numeric in the dataframe
  # This also correctly handles cases where a selected column might not exist.
  # I first check if columns exist, then if they are numeric.
  
  existing_selected_cols <- selected_col_names[selected_col_names %in% colnames(df)]
  
  # Warn about specified columns that do not exist in the dataframe
  non_existing_cols <- setdiff(selected_col_names, existing_selected_cols)
  if (length(non_existing_cols) > 0) {
    warning(paste("The following specified columns do not exist in the data frame and will be ignored:", paste(non_existing_cols, collapse = ", ")))
  }

  # From the existing selected columns, find which are numeric
  if (length(existing_selected_cols) > 0) {
    numeric_cols_to_process <- df %>%
      dplyr::select(dplyr::all_of(existing_selected_cols)) %>%
      dplyr::select(where(is.numeric)) %>%
      colnames()
  } else {
    numeric_cols_to_process <- character(0) # No existing columns to process
  }
  
  # Warn about selected columns that are non-numeric
  non_numeric_selected <- setdiff(existing_selected_cols, numeric_cols_to_process)
  if (length(non_numeric_selected) > 0) {
    warning(paste("Non-numeric columns were specified and will be ignored for outlier removal:"
                  , paste(non_numeric_selected, collapse = ", ")))
  }

  # If there are no numeric columns to process (either none specified, none existed, or none were numeric),
  # return the original dataframe.
  if (length(numeric_cols_to_process) == 0) {
    if(length(existing_selected_cols) > 0){ # If some columns were specified but none were numeric
         warning("No numeric columns among the specified variables to process for outliers. Returning original data frame.")
    }
    return(df)
  }

  # Filter the dataframe:
  # A row is kept if, for ALL specified numeric columns to process,
  # the value is either NA OR its absolute z-score is within the threshold.
  # This means a row is REMOVED if ANY specified numeric column has a non-NA
  # value whose absolute z-score is GREATER than sd_thresh.
  df_filtered <- df %>%
    dplyr::filter(
      dplyr::if_all(
        .cols = dplyr::all_of(numeric_cols_to_process),
        .fns = ~ {
          # Calculate mean and sd, ignoring NAs
          col_mean <- mean(., na.rm = TRUE)
          col_sd <- sd(., na.rm = TRUE)
          
          # If sd is NA (e.g., all NA column) or zero (no variance),
          # then consider no values as outliers for this column.
          # Also, if the value itself is NA, it's not an outlier by this definition.
          is_na_val <- is.na(.)
          if (is.na(col_sd) || col_sd == 0) {
            TRUE # Keep all values (including NAs, handled by is_na_val later)
          } else {
            abs((. - col_mean) / col_sd) <= sd_thresh
          }
        } | is.na(.) # Explicitly keep rows where the value in the current column is NA
      )
    )
  
  return(df_filtered)
}
```

## Testing Your Function!

```{r}
#| label: exercise-1-test
#| error: true

## Testing how your function handles multiple input variables
remove_outliers(diamonds, 
                price, 
                x, 
                y, 
                z)

## Testing how your function handles an input that isn't numeric
remove_outliers(diamonds, 
                price, 
                color)

## Testing how your function handles a non-default sd_thresh
remove_outliers(diamonds, 
                price,
                x, 
                y, 
                z, 
                sd_thresh = 2)
```

**Exercise 2:** Write a function that imputes missing values for numeric variables in a dataset. The user should be able to supply the dataset, the variables to impute values for, and a function to use when imputing. *Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.* *Hint 2: The `replace_na()` function is helpful here!*

```{r}
#| label: exercise-2

#' @param df A data frame.
#' @param ... Unquoted names of columns in which to impute missing values.
#' @param impute_fun A function to be used for imputation (e.g., `mean`, `median`).
#'   This function will be applied to the non-missing values of a column to
#'   calculate the imputation value. It should return a single scalar value.
#'   Defaults to `mean`.
#' @return A data frame with missing values imputed in the specified numeric columns.
#'   Non-numeric columns specified in `...` are ignored with a warning.
#'   If a specified column is entirely NA, or if the `impute_fun` does not return
#'   a single scalar value, NAs in that column will be preserved.


impute_missing <- function(df, ..., impute_fun = mean) {
  # Capture the unquoted column names passed via ...
  vars_to_impute <- rlang::enquos(...)

  # If no variables are specified, return the original dataframe with a warning
  if (length(vars_to_impute) == 0) {
    warning("No variables specified for imputation. Returning original data frame.")
    return(df)
  }

  # Get the names of the specified columns
  selected_col_names <- purrr::map_chr(vars_to_impute, rlang::as_name)

  # Identify which of the selected columns actually exist in the dataframe
  existing_selected_cols <- selected_col_names[selected_col_names %in% colnames(df)]
  
  # Warn about specified columns that do not exist in the dataframe
  non_existing_cols <- setdiff(selected_col_names, existing_selected_cols)
  if (length(non_existing_cols) > 0) {
    warning(paste("The following specified columns do not exist in the data frame and will be ignored for imputation:",
                  paste(non_existing_cols, collapse = ", ")))
  }

  # From the existing selected columns, find which are numeric
  if (length(existing_selected_cols) > 0) {
    # Get the actual numeric columns from the dataframe that were selected
    numeric_cols_to_process <- df %>%
      dplyr::select(dplyr::any_of(existing_selected_cols)) %>% # Use any_of to avoid error if a col was filtered by previous check
      dplyr::select(where(is.numeric)) %>%
      colnames()
  } else {
    numeric_cols_to_process <- character(0) # No existing columns to process
  }
  
  # Warn about selected columns that are non-numeric (among the existing ones)
  non_numeric_selected <- setdiff(existing_selected_cols, numeric_cols_to_process)
  if (length(non_numeric_selected) > 0) {
    warning(paste("Non-numeric columns were specified and will be ignored for imputation:",
                  paste(non_numeric_selected, collapse = ", ")))
  }

  # If there are no numeric columns to process (either none specified, none existed, or none were numeric),
  # return the original dataframe.
  if (length(numeric_cols_to_process) == 0) {
    if(length(existing_selected_cols) > 0 && length(non_existing_cols) < length(selected_col_names)){ # If some valid columns were specified but none were numeric
         warning("No numeric columns among the specified variables to process for imputation. Returning original data frame.")
    }
    # If no columns were specified at all, that's handled by the first check.
    # If all specified columns didn't exist, that warning was also issued.
    return(df)
  }

  # Perform imputation on the identified numeric columns
  df_imputed <- df %>%
    dplyr::mutate(
      dplyr::across(
        .cols = dplyr::all_of(numeric_cols_to_process),
        .fns = ~ {
          current_col_name <- dplyr::cur_column() # Get current column name for warnings
          valid_values <- .[!is.na(.)] # Extract non-missing values
          
          imputation_value <- NA # Default to NA if issues arise
          
          if (length(valid_values) == 0) {
            # If all values in the column are NA, or column is empty,
            # there's no basis for computing an imputation statistic.
            # NAs will be preserved by using NA as the imputation_value.
            # A warning might be useful here too, but for now, we just preserve NAs.
            # warning(paste0("Column '", current_col_name, "' is all NA. NAs will be preserved."))
            imputation_value <- NA 
          } else {
            # Try to compute the imputation value using the provided function
            temp_imputation_value <- tryCatch(
                impute_fun(valid_values),
                error = function(e) {
                    warning(paste0("Error applying imputation function to column '", current_col_name, "': ", e$message, ". NAs will be preserved."))
                    return(NA) # Return NA on error
                }
            )
            
            # Check if the imputation_value is a single atomic value
            if (length(temp_imputation_value) == 1 && is.atomic(temp_imputation_value)) {
              imputation_value <- temp_imputation_value
            } else {
              warning(paste0("Imputation function for column '", current_col_name, 
                             "' did not return a single atomic value. ",
                             "Original NAs in this column will be preserved."))
              imputation_value <- NA # Fallback to NA
            }
          }
          
          # Replace NAs with the calculated (or fallback NA) imputation value
          tidyr::replace_na(., imputation_value)
        }
      )
    )
  
  return(df_imputed)
}
```

## Testing Your Function!

```{r}
#| label: exercise-2-test
#| error: true

## Testing how your function handles multiple input variables
impute_missing(nycflights13::flights, 
               arr_delay, 
               dep_delay) 

## Testing how your function handles an input that isn't numeric
impute_missing(nycflights13::flights, 
               arr_delay, 
               carrier)

## Testing how your function handles a non-default impute_fun
impute_missing(nycflights13::flights, 
               arr_delay, 
               dep_delay, 
               impute_fun = median)
```

# Primary Function

**Exercise 3:** Write a `fit_model()` function that fits a specified linear regression model for a specified dataset. The function should:

-   allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)
-   allow the user to specify if missing observations should be imputed (`TRUE` or `FALSE`)

If either option is `TRUE`, your function should call your `remove_outliers()` or `impute_missing()` functions to modify the data **before** the regression model is fit.

```{r}
#| label: exercise-3

#' @param df A data frame.
#' @param mod_formula A formula object or a string that can be coerced to a
#'   formula, specifying the linear model to be fit (e.g., `price ~ carat + cut`).
#' @param remove_outliers Logical. If TRUE, outliers will be removed from the
#'   variables specified in `...` before model fitting, using the
#'   `remove_outliers()` function. Defaults to FALSE.
#' @param impute_missing Logical. If TRUE, missing values will be imputed in the
#'   variables specified in `...` before model fitting, using the
#'   `impute_missing()` function. Defaults to FALSE.
#' @param ... Unquoted names of columns to be processed by `remove_outliers()`
#'   and/or `impute_missing()`. These functions will use their own default
#'   settings for `sd_thresh` and `impute_fun` respectively, unless those
#'   functions are modified or these parameters are explicitly passed if the
#'   helper functions are adapted to take them from `fit_model`'s `...`.
#' @return An `lm` object representing the fitted linear model.


fit_model <- function(df, mod_formula, remove_outliers = FALSE, impute_missing = FALSE, ...) {
  # Capture the unquoted column names passed via ... for preprocessing
  vars_for_processing <- rlang::enquos(...)

  # Make a copy of the dataframe to avoid modifying the original object passed to the function
  processed_df <- df

  # Step 1: Remove outliers if requested
  if (remove_outliers) {
    if (length(vars_for_processing) == 0 && !is.null(rlang::dots_list(...))) {
      # This condition handles if ... was explicitly NULL or empty list.
      # The main check for no variables is inside remove_outliers.
      # Here, we ensure if remove_outliers is TRUE, we intend to pass something or let it warn.
    }
    # Call remove_outliers, passing the captured variables using !!! (bang-bang-bang)
    # The remove_outliers function itself will warn if no variables are effectively passed or if they are non-numeric.
    # It uses its own default for sd_thresh.
    processed_df <- remove_outliers(processed_df, !!!vars_for_processing)
    message(paste("After outlier removal (if any variables were processed), data has", nrow(processed_df), "rows."))
  }

  # Step 2: Impute missing values if requested
  # This is applied to the data potentially modified by outlier removal
  if (impute_missing) {
    if (length(vars_for_processing) == 0 && !is.null(rlang::dots_list(...))) {
      # Similar check as above for imputation.
    }
    # Call impute_missing, passing the captured variables
    # The impute_missing function itself will warn if no variables are effectively passed or if they are non-numeric.
    # It uses its own default for impute_fun.
    processed_df <- impute_missing(processed_df, !!!vars_for_processing)
    message("Missing value imputation attempted (if any variables were processed).")
  }

  # Step 3: Fit the linear model
  # Ensure mod_formula is a formula object
  if (!inherits(mod_formula, "formula")) {
    current_env <- rlang::caller_env() # Get the calling environment for the formula
    mod_formula_str <- mod_formula # Keep original if it's a string for error message
    mod_formula <- tryCatch(
      stats::as.formula(mod_formula, env = current_env), # Use stats::as.formula
      error = function(e) {
        stop(paste0("mod_formula '", mod_formula_str, "' could not be converted to a formula: ", e$message))
      }
    )
  }
  
  # Fit the model using lm() from the stats package
  # Using tryCatch to provide a more informative error if lm fails
  model <- tryCatch({
    stats::lm(mod_formula, data = processed_df)
  }, error = function(e) {
    stop(paste0("Failed to fit linear model: ", e$message, 
                "\nCheck your formula and the processed data. After preprocessing, the data has ", 
                nrow(processed_df), " rows and ", ncol(processed_df), " columns."))
  })
  
  return(model)
}
```

## Testing Your Function!

```{r}
#| label: exercise-3-test

fit_model(
  diamonds,
  mod_formula = price ~ carat + cut,
  remove_outliers = TRUE,
  impute_missing = TRUE,
  price, 
  carat
)
```

# Iteration

In the `diamonds` dataset, we want to understand the relationship between `price` and size (`carat`). We want to explore variation along two choices:

1.  The variables included in the model. We'll explore 3 sets of variables:

    -   No further variables (just `price` and `carat`)
    -   Adjusting for `cut`
    -   Adjusting for `cut` and `clarity`
    -   Adjusting for `cut`, `clarity`, and `color`

2.  Whether or not to impute missing values

3.  Whether or not to remove outliers in the `carat` variable (we'll define outliers as cases whose `carat` is over 3 SDs away from the mean).

## Parameters

First, we need to define the set of parameters we want to iterate the `fit_model()` function over. The `tidyr` package has a useful function called `crossing()` that is useful for generating argument combinations. For each argument, we specify all possible values for that argument and `crossing()` generates all combinations. *Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*

```{r}
#| label: example-crossing-arguments
#| eval: false

df_arg_combos <- crossing(
    impute = c(TRUE, FALSE),
    remove_outliers = c(TRUE, FALSE), 
    mod = c(y ~ x1, 
            y ~ x1 + x2)
)
df_arg_combos
```

**Exercise 4:** Use `crossing()` to create the data frame of argument combinations for our analyses.

```{r}
#| label: exercise-4

# 1. Define the list of model formulas to be tested.
# These formulas specify the different linear regression models we want to fit.
# The dependent variable is 'price', and the independent variables change.
model_formulas <- list(
  price ~ carat,
  price ~ carat + cut,
  price ~ carat + cut + clarity,
  price ~ carat + cut + clarity + color
)

# 2. Define the options for imputing missing values.
# This will be a logical vector: TRUE (impute) or FALSE (do not impute).
# This corresponds to the 'impute_missing' argument in the fit_model function.
imputation_options <- c(TRUE, FALSE)

# 3. Define the options for removing outliers.
# This will also be a logical vector: TRUE (remove) or FALSE (do not remove).
# This corresponds to the 'remove_outliers' argument in the fit_model function.
# The lab specifies that outlier removal should focus on the 'carat' variable.
outlier_removal_options <- c(TRUE, FALSE)

# 4. Use tidyr::crossing() to create all combinations of these arguments.
# The column names in the resulting tibble (df_arg_combos) are chosen to match
# the argument names in our `fit_model` function for easier use with `purrr::pmap`
# in Exercise 5.
df_arg_combos <- tidyr::crossing(
  mod_formula = model_formulas,         # Each of the 4 formulas
  impute_missing = imputation_options,  # TRUE or FALSE
  remove_outliers = outlier_removal_options # TRUE or FALSE
)

# 5. Print the resulting data frame of argument combinations.
# This tibble will have 4 (formulas) * 2 (impute options) * 2 (outlier options) = 16 rows.
# The 'mod_formula' column will be a list-column containing the formula objects.
print(df_arg_combos)
```

## Iterating Over the Parameters

We've arrived at the final step!

**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to every combination of arguments from \`diamonds.

```{r}
#| label: exercise-5

# Check if df_arg_combos exists, if not, stop with a message.
# This is a defensive check; in a Quarto document, it should exist if Ex4 chunk was run.
if (!exists("df_arg_combos")) {
  stop("The 'df_arg_combos' tibble is not defined. Please run the code for Exercise 4 first.")
}

# Corrected check for the existence and type of 'fit_model'
if (!exists("fit_model") || !is.function(get("fit_model"))) {
    stop("The 'fit_model' function is not defined or is not a function. Please ensure the code for Exercise 3 has been run correctly and that 'fit_model' is loaded into the environment.")
}
# Similar checks could be added for remove_outliers and impute_missing if needed:
# if (!exists("remove_outliers") || !is.function(get("remove_outliers"))) {
#   stop("The 'remove_outliers' function is not defined or is not a function. Please ensure Exercise 1 code has run.")
# }
# if (!exists("impute_missing") || !is.function(get("impute_missing"))) {
#   stop("The 'impute_missing' function is not defined or is not a function. Please ensure Exercise 2 code has run.")
# }


# Use pmap() to apply the fit_model() function to every combination of arguments.
# We will add the resulting model objects as a new list-column to df_arg_combos.
# The arguments for pmap are:
# .l: A list of arguments to iterate over. Here, we use a list of columns
#     from df_arg_combos (mod_formula, impute_missing, remove_outliers).
# .f: The function to apply, which is fit_model.
# Additional arguments for fit_model (df and the ... part for 'carat') are passed directly.

message("Starting model fitting for ", nrow(df_arg_combos), " combinations...")

df_results <- df_arg_combos %>%
  dplyr::mutate(
    # Create a new column named 'model_object'
    model_object = purrr::pmap(
      # .l is a list where each element corresponds to an argument of fit_model
      # that varies with each row of df_arg_combos.
      .l = list(
        mod_formula = mod_formula,           # Taken from the 'mod_formula' column
        impute_missing = impute_missing,     # Taken from the 'impute_missing' column
        remove_outliers = remove_outliers    # Taken from the 'remove_outliers' column
      ),
      # .f is the function to be called for each combination of arguments from .l
      .f = fit_model,
      # Additional arguments to fit_model that are fixed for all calls:
      df = diamonds,  # The dataset to use
      carat           # Variable to be passed to `...` in fit_model for processing.
                      # remove_outliers and impute_missing will use this.
    )
  )

message("Model fitting complete. Results are in 'df_results'.")

# Print the resulting tibble.
# It will now have an additional column 'model_object' containing the list of lm models.
print(df_results)
```
